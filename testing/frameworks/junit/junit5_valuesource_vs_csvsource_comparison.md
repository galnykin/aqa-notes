# ValueSource и CsvSource в JUnit 5: выбор аннотации для параметризованных тестов

Краткое сравнение двух популярных аннотаций JUnit 5 для параметризации тестов с примерами использования и рекомендациями по выбору.

## Введение

JUnit 5 предоставляет несколько способов параметризации тестов, среди которых `@ValueSource` и `@CsvSource` являются одними из наиболее часто используемых. Понимание различий между ними помогает выбирать правильный инструмент для конкретных сценариев тестирования.

## ValueSource: простые значения

`@ValueSource` предназначена для передачи одного параметра простого типа в тестовый метод. Аннотация поддерживает различные типы данных:

```java
@ParameterizedTest
@ValueSource(strings = {"apple", "banana", ""})
void testStringValues(String value) {
    assertTrue(value.length() <= 6);
}

@ParameterizedTest
@ValueSource(ints = {1, 5, 10})
void testNumbers(int number) {
    assertTrue(number > 0);
}
```

**Преимущества ValueSource:**
- Простой синтаксис для одиночных значений
- Поддержка всех примитивных типов и строк
- Минимальная конфигурация

## CsvSource: структурированные данные

`@CsvSource` позволяет передавать несколько связанных параметров в формате, аналогичном CSV:

```java
@ParameterizedTest
@CsvSource({
    "apple, 1, true",
    "banana, 2, false", 
    "orange, 3, true"
})
void testWithMultipleParameters(String fruit, int quantity, boolean available) {
    assertNotNull(fruit);
    assertTrue(quantity > 0);
    // Дополнительные проверки
}
```

**Возможности CsvSource:**
- Передача нескольких параметров за один вызов
- Настройка разделителя через `delimiter`
- Конвертация типов данных
- Поддержка null-значений через `NULL`

## Сравнительный анализ

| Критерий | ValueSource | CsvSource |
|----------|-------------|-----------|
| Параметры на вызов | Один | Несколько |
| Типы данных | Простые типы | Любые (с конвертацией) |
| Читаемость | Высокая для простых случаев | Высокая для связанных данных |
| Гибкость | Ограниченная | Высокая |

## Рекомендации по выбору

**Используйте ValueSource когда:**
- Тестируете один параметр простого типа
- Нужен минимальный и чистый синтаксис
- Данные представляют собой простые значения

**Выбирайте CsvSource когда:**
- Тесту требуется несколько связанных параметров
- Данные естественно группируются в наборы
- Нужно передавать разные типы данных в одном вызове
- Требуется читаемое представление связанных данных

## Практические примеры

### Пример с ValueSource (валидация email)
```java
@ParameterizedTest
@ValueSource(strings = {
    "test@example.com",
    "user.name@domain.com", 
    "invalid-email"
})
void testEmailValidation(String email) {
    boolean isValid = EmailValidator.isValid(email);
    // Assertions...
}
```

### Пример с CsvSource (тестирование калькулятора)
```java
@ParameterizedTest
@CsvSource({
    "2, 3, 5",
    "10, -5, 5", 
    "0, 0, 0"
})
void testAddition(int a, int b, int expected) {
    assertEquals(expected, Calculator.add(a, b));
}
```

## Заключение

Обе аннотации имеют свои преимущества и области применения. `ValueSource` идеален для простых сценариев с одиночными значениями, в то время как `CsvSource` предоставляет более мощные возможности для работы со структурированными данными. Выбор зависит от конкретных требований тестового сценария и структуры тестовых данных.

[**&#x2190; Назад к оглавлению**](README.md)