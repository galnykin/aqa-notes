# Формат и структура лог-сообщений

Лог-сообщения — это основа эффективного логирования, позволяющая фиксировать события, действия и ошибки в проекте так, чтобы их было легко читать и анализировать. Формат и структура сообщений определяют, насколько быстро разработчики, тестировщики и DevOps-инженеры смогут извлечь полезную информацию из логов. Эта статья описывает, как правильно формировать лог-сообщения, какие элементы они должны включать, и какие стандарты помогают сделать логи понятными и полезными для диагностики, мониторинга и аудита.

## Почему важен формат лог-сообщений

Хорошо структурированные лог-сообщения:
- Обеспечивают **читаемость** для людей и парсинг для инструментов анализа (например, ELK Stack).
- Содержат **контекст**, необходимый для воспроизведения событий или ошибок.
- Упрощают **фильтрацию** по уровням логирования, времени или источнику.
- Соответствуют стандартам аудита и безопасности, если требуется (например, GDPR, PCI DSS).

Плохо оформленные сообщения, напротив, могут затруднить анализ, замедлить отладку и привести к пропуску критических проблем.

## Элементы лог-сообщения

Каждое лог-сообщение должно включать ключевые элементы, чтобы быть информативным:

1. **Метка времени**: Точная дата и время события (например, `2025-10-03 20:00:00`).
    - **Зачем**: Позволяет отслеживать последовательность событий и коррелировать их.
    - **Пример**: `%d{yyyy-MM-dd HH:mm:ss}` в Log4j2.

2. **Уровень логирования**: TRACE, DEBUG, INFO, WARN, ERROR, FATAL.
    - **Зачем**: Указывает важность события и помогает фильтровать логи.
    - **Пример**: `INFO`, `ERROR`.

3. **Имя логгера или источник**: Пакет, класс или модуль, откуда пришло сообщение.
    - **Зачем**: Показывает, где в коде произошло событие.
    - **Пример**: `com.example.ui.LoginTest`.

4. **Поток выполнения**: Имя потока, в котором выполняется действие.
    - **Зачем**: Полезно в многопоточных приложениях для отслеживания параллельных операций.
    - **Пример**: `[main]` или `[TestWorker-1]`.

5. **Сообщение**: Описание события с необходимым контекстом.
    - **Зачем**: Передаёт суть события или ошибки.
    - **Пример**: `Sending API request to /users?limit=10`.

6. **Контекстные данные** (опционально): Параметры, идентификаторы, пользовательские данные.
    - **Зачем**: Упрощают воспроизведение события.
    - **Пример**: `userId=123, status=active`.

## Рекомендации по структуре сообщений

1. **Краткость и ясность**: Сообщение должно быть лаконичным, но содержать достаточно деталей.
    - Хороший пример: `Login failed for userId=123: Invalid credentials`.
    - Плохой пример: `Something went wrong`.

2. **Контекст**: Включайте ключевые параметры, такие как идентификаторы, URL или значения.
    - Хороший пример: `GET /users failed with status=500, responseTime=120ms`.
    - Плохой пример: `Request failed`.

3. **Единообразие**: Используйте одинаковый формат для всех сообщений в проекте.
    - Пример: Все сообщения начинаются с глагола в настоящем времени (`Sending`, `Processing`).

4. **Структурированный формат**: Для автоматического анализа (например, в ELK Stack) используйте JSON.
    - Пример: `{"timestamp":"2025-10-03T20:00:00","level":"INFO","message":"User logged in","userId":"123"}`.

5. **Локализация времени**: Указывайте часовой пояс (например, UTC) для согласованности.
    - Пример: `%d{yyyy-MM-dd HH:mm:ss,SSS Z}`.

## Примеры форматов в автотестах

### UI-тест (Selenium)
- Формат: `[время] [уровень] [класс] - [действие и контекст]`.
- Пример: `2025-10-03 20:00:00 [INFO] com.example.ui.LoginTest - Clicking login button for userId=123`.
- Плохо: `Clicked button`.

### API-тест (RestAssured)
- Формат: `[время] [уровень] [класс] - [метод, URL, параметры, результат]`.
- Пример: `2025-10-03 20:00:01 [DEBUG] com.example.api.ApiTest - Sending GET /users?limit=10, responseCode=200`.
- Плохо: `API call done`.

### Ошибка
- Формат: `[время] [уровень] [класс] - [ошибка, причина, контекст]`.
- Пример: `2025-10-03 20:00:02 [ERROR] com.example.ui.LoginTest - NoSuchElementException: Element #loginField not found at line 45`.
- Плохо: `Error happened`.

## Настройка формата в Log4j2

Пример настройки формата в `log4j2.properties`:
```properties
appender.Console.type = Console
appender.Console.name = Console
appender.Console.layout.type = PatternLayout
appender.Console.layout.pattern = %d{yyyy-MM-dd HH:mm:ss,SSS} [%t] %-5level %c{1} - %msg%n
```

- `%d{yyyy-MM-dd HH:mm:ss,SSS}`: Время с миллисекундами.
- `[%t]`: Поток.
- `%-5level`: Уровень, выровненный по 5 символам.
- `%c{1}`: Имя класса.
- `%msg%n`: Сообщение и перенос строки.

Для JSON-логов:
```properties
appender.JsonFile.type = File
appender.JsonFile.name = JsonFile
appender.JsonFile.fileName = logs/tests.json
appender.JsonFile.layout.type = JsonLayout
appender.JsonFile.layout.compact = true
appender.JsonFile.layout.eventEol = true
```

## Лучшие практики

- **Контекстные переменные**: Используйте параметры в сообщениях (например, `logger.info("User {} logged in", userId)`).
- **Избегайте избыточности**: Не дублируйте информацию, уже содержащуюся в метке времени или уровне.
- **Читаемость**: Пишите сообщения, понятные без исходного кода.
- **Стандарты**: Согласуйте формат с командой (например, всегда включать `userId` для действий пользователя).
- **JSON для анализа**: Используйте структурированный формат для интеграции с системами мониторинга.

## Заключение

Формат и структура лог-сообщений напрямую влияют на их полезность для отладки, мониторинга и аудита. Чёткие, контекстные и единообразные сообщения упрощают анализ логов, ускоряют диагностику и повышают качество проекта. Следующий шаг — изучение логирования действий пользователей и системы для более полного охвата событий.

---

[**← Назад к оглавлению**](../README.md)
